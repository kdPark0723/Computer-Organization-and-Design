# 컴퓨터 구조

## 기본적인 MIPS 구현

### 구현할 명령어

#### 메모리 참조 명령어

- lw

  | Operation: | $t = MEM[$s + offset]; advance_pc (4);    |
  | ---------- | ----------------------------------------- |
  | Syntax:    | lw $t, offset($s)                         |
  | Encoding:  | `1000 11ss ssst tttt iiii iiii iiii iiii` |

- sw

  | Operation: | MEM[$s + offset] = $t; advance_pc (4);    |
  | ---------- | ----------------------------------------- |
  | Syntax:    | sw $t, offset($s)                         |
  | Encoding:  | `1010 11ss ssst tttt iiii iiii iiii iiii` |

#### 산술 논리 명령어

- add

  | Operation: | $d = $s + $t; advance_pc (4);             |
  | ---------- | ----------------------------------------- |
  | Syntax:    | add $d, $s, $t                            |
  | Encoding:  | `0000 00ss ssst tttt dddd d000 0010 0000` |

- sub

  | Operation: | $d = $s - $t; advance_pc (4);             |
  | ---------- | ----------------------------------------- |
  | Syntax:    | sub $d, $s, $t                            |
  | Encoding:  | `0000 00ss ssst tttt dddd d000 0010 0010` |

- and

  | Operation: | $d = $s & $t; advance_pc (4);             |
  | ---------- | ----------------------------------------- |
  | Syntax:    | and $d, $s, $t                            |
  | Encoding:  | `0000 00ss ssst tttt dddd d000 0010 0100` |

- or

  | Operation: | $d = $s \| $t; advance_pc (4);            |
  | ---------- | ----------------------------------------- |
  | Syntax:    | or $d, $s, $t                             |
  | Encoding:  | `0000 00ss ssst tttt dddd d000 0010 0101` |

- slt

  | Operation: | if $s < $t $d = 1; advance_pc (4); else $d = 0; advance_pc (4); |
  | ---------- | ------------------------------------------------------------ |
  | Syntax:    | slt $d, $s, $t                                               |
  | Encoding:  | `0000 00ss ssst tttt dddd d000 0010 1010`                    |



#### 분기 명령어

- beq

  | Operation: | if $s == $t advance_pc (offset << 2)); else advance_pc (4); |
  | ---------- | ----------------------------------------------------------- |
  | Syntax:    | beq $s, $t, offset                                          |
  | Encoding:  | `0001 00ss ssst tttt iiii iiii iiii iiii`                   |

- j  

  | Operation: | PC = nPC; nPC = (PC & 0xf0000000) \| (target << 2); |
  | ---------- | --------------------------------------------------- |
  | Syntax:    | j target                                            |
  | Encoding:  | `0000 10ii iiii iiii iiii iiii iiii iiii`           |

### 구현 개요

#### 첫번째 단계

- 명령어 가져오기
  - PC를 메모리에 보내기
  - (READ 신호를 메모리에 보내기)

#### 두번째 단계

- 연산코드(Opcode) 해석
- 레지스터 미리 가져오기

#### 세번째 단계

##### 메모리 참조 명령어

- 주소 계산을 위해 ALU사용

##### 산술 논리 명령어

- 연산을 수행하기 위해 ALU사용

##### 분기 명령어

- 비교하기 위해 ALU사용

#### 마지막 단계

##### 메모리 참조 명령어

- 저장
  - 데이터를 기록하기 위해 메모리에 접근
- 적재
  - 데이터를 읽기 위해 메모리에 접근

##### 산술 논리 명령어

- ALU나 메모리에서 온 정보를 레지스터에 기록

##### 분기 명령어

- PC값을 비교 결과에 따라 변경

### 멀티플렉서 (Multiplexer)

- 데이터 선택기
- 제어선에 따라 여러개의 입력중에서 하나를 선택해서 출력

### 데이터패스

#### 명령어를 가져오기 위한 데이터패스 요소

- 명령어 메모리
  - 프로그램의 명령어를 저장
- 프로그램 카운터 (PC)
  - 가져올 명령어의 주소를 저장
- 덧셈기
  - PC를 다음 명령어의 주소로 증가시킴

#### 메모리 참조 명령어를 위한 데이터패스

- 주소 계산을 위해 ALU사용

- 저장
  - 데이터를 기록하기 위해 메모리에 접근
- 적재
  - 데이터를 읽기 위해 메모리에 접근



1. rs, rt가 레지스터 파일에 입력값으로 전달
2. 주소값이 부호 확장이 되어 ALU입력 값중 하나로 전달
3. 레지스터 파일의 출력값 중 첫번째는 ALU의 입력값으로 전달
4. 저장이면 4-1로 적재면 4-2로
   1. ALU의 출력을 데이터 메모리의 주소 입력값으로 전달되고 레지스터 파일의 두번째 출력값은 데이터 메모리의 쓸 데이터 값으로 전달
   2. ALU의 출력을 데이터 메모리의 주소 입력값으로 전달되고 데이터 메모리의 출력값이 레지스터 파일의 쓸 데이터로 전달

#### 산술 논리 명령어를 위한 데이터패스

- 연산을 수행하기 위해 ALU사용

- ALU나 메모리에서 온 정보를 레지스터에 기록

  

1. rs, rt, rd가 레지스터 파일에 입력값으로 전달
2. 레지스터 파일의 출력값 2개가 ALU로 입력값으로 전달
3. ALU의 출력값이 레지스터 파일의 쓸 데이터로 전달
4. rd의 위치에 ALU계산 결과가 작성됨

#### 분기 명령어를 위한 데이터패스